# Architecture
A implementation agnostic way of describing how Clusterit should work.

DEVICE a server managed by Clusterit
EXECUTOR the device that synchronizes all DEVICEs with their ROLEs 
STATE a file generated by the EXECUTOR containing all the information needed to connect to the DEVICEs and to store what is needed to sync it to the role.
MODULE a collection of EXECUTIONs and other MODULEs specific for a kind of task.
EXECUTION a single *reproducable* and *fail safe* command execution. It should throw an error on leaving an invalid state (eg. a failing health check should throw an error).

## Devices

Adding a device

```bash
clusterit add {MODULE} {HOSTNAME} [CONNECTION_OPTIONS]
```

Listing all devices

```bash
clusterit devices
```

```
DEVICE => MODULE
1.1.1.1 => k3smaster
2.2.2.2 => k3sagent
3.3.3.3 => k3sagent
4.4.4.4 => nfc
5:5:5:5:5:5:5:5 => custom
6.6.6.6 => custom
```

Synchronizing devices

```
clusterit sync
```


## EXECUTOR has a STATE file
1.1.1.1
	ssh key, port
	module synced
2.2.2.2
	ssh key, port
	module desynced
3.3.3.3
	ssh key, port
	module synced

## MODULE (following docker like format)

- Each state used in 
- Create a list of dependencies for every executable used
- Create a list of dependencies for all arguments used ($1, $2)

```dockerfile
{execution}
ARG {name} [default value]
VAR {name} {value}
DEP {key} {json value}
CMD {shell command} 
COPY {local file path} {remote file path}
MOD {module name} {args}
```

Example replace module

// FIXME make replace module safe
```dockerfile
ARG file 
ARG regex 
ARG replacement

CMD cat $file
STATE original_file !!

CMD sed $file -i 's/$regex/$replacement/g'

CMD cat $file
STATE changed_file !!

FALLBACK
CMD 
```

QUESTIONS
How to deal with different operating systems?
	- Each module checks for its executables so if the os doesn't contain it the module will fail 
